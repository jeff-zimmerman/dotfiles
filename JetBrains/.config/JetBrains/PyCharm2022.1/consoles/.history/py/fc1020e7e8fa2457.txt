inspect.stack()
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry/inspect_test.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry')
-. . -..- - / . -. - .-. -.--
import inspect

print(inspect.stack()[-1])

-. . -..- - / . -. - .-. -.--
import inspect

print(inspect.stack()[-2])

-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry/analyze.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/velocimetry')
-. . -..- - / . -. - .-. -.--
super(MultiFeaturesClassificationModel, self)(x)
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification/models/multi_features_classification_model.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification/models')
-. . -..- - / . -. - .-. -.--
Path(sys.argv[0]).parent.stem
-. . -..- - / . -. - .-. -.--
import sys
import time
from pathlib import Path
from typing import Tuple, Union, Callable

import numpy as np
import torch

from . import utils


class Run:
    def __init__(
            self,
            model: object,
            device: torch.device,
            criterion: object,
            optimizer: torch.optim.Optimizer,
            use_focal_loss: bool = False,
            use_rnn: bool = False,
            inverse_label_weight: bool = False,
    ):
        """
        Trainer class containing the boilerplate code for training and evaluation.

        Args:
            model (object): Instance of the model being used.
            device (torch.device): Device to run training/inference on.
            criterion (object): Instance of the loss function being used.
            optimizer (torch.optim.Optimizer): Optimizer used during training.
            use_focal_loss (bool): If true, use focal loss. It is supposed to work better in class imbalance problems. See: https://arxiv.org/pdf/1708.02002.pdf
            use_rnn (bool): If true, use a recurrent neural network. It makes sure to take predictions at the last time step.
        """
        self.model = model
        self.criterion = criterion
        self.optimizer = optimizer
        self.device = device
        self.use_focal_loss = use_focal_loss
        self.use_rnn = use_rnn
        self.inverse_label_weight = inverse_label_weight

    def train(
            self,
            data_loader: torch.utils.data.DataLoader,
            epoch: int,
            scheduler: Union[Callable, None] = None,
            print_every: int = 100,
    ) -> float:
        batch_time = utils.MetricMonitor()
        data_time = utils.MetricMonitor()
        losses = utils.MetricMonitor()

        # put the model to train mode
        self.model.train()

        start = end = time.time()
        for batch_idx, (images, labels) in enumerate(data_loader):
            # data loading time
            data_time.update(time.time() - end)

            # zero out all the accumulated gradients
            self.optimizer.zero_grad()

            # send the data to device
            images = images.to(self.device, dtype=torch.float)
            labels = labels.to(self.device, dtype=torch.float)

            batch_size = images.size(0)

            # forward pass
            y_preds = self.model(images)

            # use predictions for the last time step for RNN
            if self.use_rnn:
                y_preds = y_preds.squeeze()[:, -1]

            if Path(sys.argv[0]).parent.stem == 'turbulence_regime_classification':
                loss = self.criterion(y_preds.squeeze(), labels.type(torch.long))
            else:
                loss = self.criterion(y_preds.squeeze(), labels.type_as(y_preds))

            if not torch.all(torch.isfinite(loss)):
                assert False

            if self.use_focal_loss:
                loss = self._focal_loss(labels, y_preds, loss)

            if self.inverse_label_weight:
                loss = torch.div(loss, labels)

            # perform loss reduction
            loss = loss.mean()

            # record loss
            losses.update(loss.item(), batch_size)

            # backpropagate
            loss.backward()

            # optimizer step
            self.optimizer.step()

            for p in self.model.parameters():
                if p.requires_grad and not torch.all(torch.isfinite(p)):
                    assert False

            # elapsed time
            batch_time.update(time.time() - end)
            end = time.time()

            # step the scheduler if provided
            if scheduler is not None:
                scheduler.step()

            # display results
            if (batch_idx + 1) % print_every == 0:
                print(
                    f"Epoch: [{epoch + 1}][{batch_idx + 1}/{len(data_loader)}] "
                    f"Batch time: {batch_time.val:.3f} ({batch_time.avg:.3f}) "
                    f"Elapsed {utils.time_since(start, float(batch_idx + 1) / len(data_loader))} "
                    f"Loss: {losses.val:.4f} ({losses.avg:.4f}) "
                )

        return losses.avg

    def evaluate(
            self,
            data_loader: torch.utils.data.DataLoader,
            print_every: int = 50,
    ) -> Tuple[float, np.ndarray, np.ndarray]:
        batch_time = utils.MetricMonitor()
        data_time = utils.MetricMonitor()
        losses = utils.MetricMonitor()

        # switch the model to evaluation mode
        self.model.eval()
        preds = []
        valid_labels = []
        start = end = time.time()
        images_cwt = None
        for batch_idx, (images, labels) in enumerate(data_loader):
            # measure data loading time
            data_time.update(time.time() - end)

            # send the data to device
            images = images.to(self.device, dtype=torch.float)
            labels = labels.to(self.device, dtype=torch.float)

            batch_size = images.size(0)

            # compute loss with no backprop
            with torch.no_grad():
                y_preds = self.model(images)

            if self.use_rnn:
                y_preds = y_preds.squeeze()[:, -1]

            loss = self.criterion(y_preds.squeeze(), labels.type_as(y_preds))

            if self.use_focal_loss:
                loss = self._focal_loss(labels, y_preds, loss)

            if self.inverse_label_weight:
                loss = torch.div(loss, labels)

            # perform loss reduction
            loss = loss.mean()

            losses.update(loss.item(), batch_size)

            # record accuracy
            if type(self.criterion).__name__ == 'MSELoss':
                preds.append(y_preds.cpu().numpy())
            elif type(self.criterion).__name__ == 'CrossEntropyLoss':
                preds.append((torch.nn.Softmax(dim=1)(y_preds).cpu().numpy()))
            else:
                preds.append(y_preds.sigmoid().cpu().numpy())
            valid_labels.append(labels.cpu().numpy())

            # measure elapsed time
            batch_time.update(time.time() - end)
            end = time.time()

            # display results
            if (batch_idx + 1) % print_every == 0:
                print(
                    f"Evaluating: [{batch_idx + 1}/{len(data_loader)}] "
                    f"Batch time: {batch_time.val:.3f} ({batch_time.avg:.3f}) "
                    f"Elapsed {utils.time_since(start, float(batch_idx + 1) / len(data_loader))} "
                    f"Loss: {losses.val:.4f} ({losses.avg:.4f}) "
                )
        predictions = np.concatenate(preds)
        targets = np.concatenate(valid_labels)

        return losses.avg, predictions, targets

    @staticmethod
    def _focal_loss(y_true, y_preds, loss, gamma=2):
        probas = torch.sigmoid(y_preds)
        loss = torch.where(
            y_true >= 0.5,
            (1.0 - probas) ** gamma * loss,
            probas ** gamma * loss,
            )
        return loss

-. . -..- - / . -. - .-. -.--
import inspect
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data', 'w+') as f:
    f.create_dataset('signals', data=np.array(hf['signals'])[:500])
    f.create_dataset('time', data=np.array(hf['time'])[:500])
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'])[:500])
    f.create_dataset('time', data=np.array(hf['time'])[:500])
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'])[:500])
    f.create_dataset('time', data=np.array(hf['time'])[:500])
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:500]))
    f.create_dataset('time', data=np.array(hf['time'][:500]))
    
-. . -..- - / . -. - .-. -.--
hf['signals']
-. . -..- - / . -. - .-. -.--
hf['signals'][:500]
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :500]))
    f.create_dataset('time', data=np.array(hf['time'][:500]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :500]))
    f.create_dataset('vR', data=np.array(hf['vR'][:, :500]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:, :500]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:, :500]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:, :500]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:, :500]))
    
-. . -..- - / . -. - .-. -.--
for key in list(hf):
    print(key, ': ',hf[key].shape)
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :500]))
    f.create_dataset('vR', data=np.array(hf['vR'][:500, ...]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:500, ...]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:500, ...]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:500, ...]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:500, ...]))
    
-. . -..- - / . -. - .-. -.--
len(hf_short['signals'])
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :1000]))
    f.create_dataset('vR', data=np.array(hf['vR'][:1000, ...]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:1000, ...]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:1000, ...]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:1000, ...]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:1000, ...]))
    
-. . -..- - / . -. - .-. -.--
hf_short = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5')
-. . -..- - / . -. - .-. -.--
list(hf_short)
-. . -..- - / . -. - .-. -.--
hf_short['signals'].shape
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:1000]))
    f.create_dataset('time', data=np.array(hf['time'][:1000]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:1500]))
    f.create_dataset('time', data=np.array(hf['time'][:1500]))
    
-. . -..- - / . -. - .-. -.--
hf = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-work/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5')
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :1500]))
    f.create_dataset('vR', data=np.array(hf['vR'][:1500, ...]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:1500, ...]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:1500, ...]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:1500, ...]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:1500, ...]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :2000]))
    f.create_dataset('vR', data=np.array(hf['vR'][:2000, ...]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:2000, ...]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:2000, ...]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:2000, ...]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:2000, ...]))
    
-. . -..- - / . -. - .-. -.--
hf = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-work/regime_classification/data/bes_signals_149992.hdf5')
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:2000]))
    f.create_dataset('time', data=np.array(hf['time'][:2000]))
    
-. . -..- - / . -. - .-. -.--
fs = [1, 2, 3, 4, -1]
-. . -..- - / . -. - .-. -.--
all([l>=0 for l in fs])
-. . -..- - / . -. - .-. -.--
all([l >= 0 for l in fs])
-. . -..- - / . -. - .-. -.--
assert (all([l >= 0 for l in fs]), "There are not enough data points to make dataset.")
-. . -..- - / . -. - .-. -.--
assert all([l >= 0 for l in fs])
-. . -..- - / . -. - .-. -.--
assert all([l >= 0 for l in fs]), 'ASDF'
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:2500]))
    f.create_dataset('time', data=np.array(hf['time'][:2500]))
    
-. . -..- - / . -. - .-. -.--
hf2 = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-work/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5')
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, :2500]))
    f.create_dataset('vR', data=np.array(hf['vR'][:2500, ...]))
    f.create_dataset('vZ', data=np.array(hf['vZ'][:2500, ...]))
    f.create_dataset('vR_std', data=np.array(hf['vR_std'][:2500, ...]))
    f.create_dataset('vZ_std', data=np.array(hf['vZ_std'][:2500, ...]))
    f.create_dataset('signals_interp', data=np.array(hf['signals_interp'][:2500, ...]))
    
-. . -..- - / . -. - .-. -.--
list(hf2)
-. . -..- - / . -. - .-. -.--
hf_short.close()
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/data/velocimetry_data_shot_171472_labeled.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf2['signals'][:, :2500]))
    f.create_dataset('vR', data=np.array(hf2['vR'][:2500, ...]))
    f.create_dataset('vZ', data=np.array(hf2['vZ'][:2500, ...]))
    f.create_dataset('vR_std', data=np.array(hf2['vR_std'][:2500, ...]))
    f.create_dataset('vZ_std', data=np.array(hf2['vZ_std'][:2500, ...]))
    f.create_dataset('signals_interp', data=np.array(hf2['signals_interp'][:2500, ...]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, 2500]))
    f.create_dataset('time', data=np.array(hf['time'][:2500]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, 5000]))
    f.create_dataset('time', data=np.array(hf['time'][:5000]))
    
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf['signals'][:, 4500]))
    f.create_dataset('time', data=np.array(hf['time'][:4500]))
    
-. . -..- - / . -. - .-. -.--
hf['signals'].shape
-. . -..- - / . -. - .-. -.--
f.open()
-. . -..- - / . -. - .-. -.--
list(hf)
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf1['signals'][:, 4500]))
    f.create_dataset('time', data=np.array(hf1['time'][:4500]))
    
-. . -..- - / . -. - .-. -.--
hf1_short['signals'].shape
-. . -..- - / . -. - .-. -.--
hf1['signals'].shape
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf1['signals'][:, :4500]))
    f.create_dataset('time', data=np.array(hf1['time'][:4500]))
    
-. . -..- - / . -. - .-. -.--
b = np.hstack((t,i))
-. . -..- - / . -. - .-. -.--
import h5py
-. . -..- - / . -. - .-. -.--
import numpy as np
-. . -..- - / . -. - .-. -.--
hf1_short = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5')
-. . -..- - / . -. - .-. -.--
hf1 = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-work/regime_classification/data/bes_signals_149992.hdf5')
-. . -..- - / . -. - .-. -.--
t = np.array(hf1['time'])
-. . -..- - / . -. - .-. -.--
b = b[[t>=2500 & t<=4500]]
-. . -..- - / . -. - .-. -.--
b = b[[x>=2500 & x<=4500 for x in t]]
-. . -..- - / . -. - .-. -.--
b = b[t>=2500 & t<=4500]
-. . -..- - / . -. - .-. -.--
[t>=4500]
-. . -..- - / . -. - .-. -.--
[t<=4500 & t>=2500]
-. . -..- - / . -. - .-. -.--
[t<=4500 and t>=2500]
-. . -..- - / . -. - .-. -.--
b = b[np.where((t>=2500) & (t<=4500))]
-. . -..- - / . -. - .-. -.--
hf1_short.close()
-. . -..- - / . -. - .-. -.--
i = i[:10:]
-. . -..- - / . -. - .-. -.--
i = i[:,10,:]
-. . -..- - / . -. - .-. -.--
i = i[::10]
-. . -..- - / . -. - .-. -.--
i = i[1:]
-. . -..- - / . -. - .-. -.--
i = i[::4]
-. . -..- - / . -. - .-. -.--
i = b[:, 1].squeeze()
-. . -..- - / . -. - .-. -.--
i = i.astype(int)
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_149992.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf1['signals'][:, i]))
    f.create_dataset('time', data=np.array(hf1['time'][i]))
    
-. . -..- - / . -. - .-. -.--
hf2 = h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-work/regime_classification/data/bes_signals_175490.hdf5')
-. . -..- - / . -. - .-. -.--
t = np.array(hf2['time'])
-. . -..- - / . -. - .-. -.--
i = np.arange(len(t))
-. . -..- - / . -. - .-. -.--
b = np.vstack((t, i))
-. . -..- - / . -. - .-. -.--
b = b.T
-. . -..- - / . -. - .-. -.--
b = b[np.where((t>=2100) & (t<=4600))]
-. . -..- - / . -. - .-. -.--
i = b[:, 1].squeeze().astype(int)
-. . -..- - / . -. - .-. -.--
i = i[::100]
-. . -..- - / . -. - .-. -.--
with h5py.File('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/data/bes_signals_175490.hdf5', 'w') as f:
    f.create_dataset('signals', data=np.array(hf2['signals'][:, i]))
    f.create_dataset('time', data=np.array(hf2['time'][i]))
    
-. . -..- - / . -. - .-. -.--
int(np.trunc(len(shots_files) * test_frac))
-. . -..- - / . -. - .-. -.--
1 * False
-. . -..- - / . -. - .-. -.--
1 + ~bool(int(np.floor(len(shots_files) * test_frac)))
-. . -..- - / . -. - .-. -.--
~False
-. . -..- - / . -. - .-. -.--
not False
-. . -..- - / . -. - .-. -.--
~bool(int(np.floor(len(shots_files) * test_frac))) + 1
-. . -..- - / . -. - .-. -.--
bool(int(np.floor(len(shots_files) * test_frac))) + 1
-. . -..- - / . -. - .-. -.--
n_test if n_test else 1
-. . -..- - / . -. - .-. -.--
n_test
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/elm_prediction/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/elm_prediction')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry')
-. . -..- - / . -. - .-. -.--
run.plot_full_inference(run)
-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=10e-5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=10e-5, vmax=100))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=-5, vmax=100))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=-5, vmax=10))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=10))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=4, vmax=5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=0.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=LogNorm())

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/2, interpolation='hanning', cmap='brg')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
from matplotlib.colors import Lognorm
-. . -..- - / . -. - .-. -.--
from matplotlib.colors import LogNorm
-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]+signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm())

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]+signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=1))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
signals[time_slice]
-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=1))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=0.01))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=0.10))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=10))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def merge_all_pdfs(self):
    pdf_files = sorted(
        self.analysis_dir.glob('*.pdf'),
        key=lambda path: path.stat().st_mtime_ns,
    )
    output = self.analysis_dir/'all_figures.pdf'
    print(f"Merging all PDFs into file: {output.as_posix()}")
    utils.merge_pdfs(pdf_files, output, delete_inputs=False)

def plot_all(self):
    self.plot_training_epochs()
    self.plot_full_inference()
    self.merge_all_pdfs()

def show(self, **kwargs):
    plt.show(**kwargs)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=0.000001))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=100))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=10e5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg',
                   norm=LogNorm(vmin=0, vmax=10e6))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]-signals[time_slice].min(), interpolation='hanning', cmap='brg')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gnuplot2')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='viridis')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='jet')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_heat')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='seismic')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='RdYlGn')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='hsv')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='inferno')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
'Perceptually Uniform Sequential',
-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='plasma')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
from matplotlib.colors import TwoSlopeNorm
-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_ncar',
                   norm=TwoSlopeNorm())

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_ncar',
                   norm=TwoSlopeNorm(vcenter=0.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='grb',
                   norm=TwoSlopeNorm(vcenter=0.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=0.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=0.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=2.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=1.5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='brg',
                   norm=TwoSlopeNorm(vcenter=0.8))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.8, vmax=2.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.8, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.8, vmax=0.9))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.02, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.0, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=-0.2, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=-0.8, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.6, vmax=1.0))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.6, vmax=1.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.2, vmax=1.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.2, vmax=1.5))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
plot_full_inference(run)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.2, vmax=15))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice]/signals[time_slice].max(), interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.2, vmax=0.9))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.02))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=0.8))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=1.2))

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern',
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[2].quiver(vR_labels, vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.5,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[2].quiver(vR_labels, vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.5,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[2].quiver(U=vR_labels, V=vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.5,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[2].quiver(X=None, Y=None, U=vR_labels, V=vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[2].quiver(None, None, vR_labels, vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    Y, X = np.mgrid[0:8, 0:8]
    axes[2].quiver(X, Y, vR_labels, vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    Y, X = np.mgrid[0:8, 0:8]
    print(Y, X)
    axes[2].quiver(X, Y, vR_labels, vZ_labels)
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    Y, X = np.mgrid[0:8, 0:8]
    axes[2].quiver(X, Y, vR_labels[time_slice], vZ_labels[time_slice])
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    Y, X = np.mgrid[0:8, 0:8]
    axes[2].quiver(X, Y, vR_labels[time_slice], vZ_labels[time_slice])
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')
    axes[2].set_title('ODP Calculated Velocity Field')

    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[3].quiver(X, Y, vR_predictions[time_slice], vZ_predictions[time_slice])
    axes[3].set_xlabel('R')
    axes[3].set_ylabel('Z')
    axes[3].set_title('ML Calculated Velocity Field')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
def plot_full_inference(
        self,
        max_elms=None,
        time_slice=None,
):
    if not self.vel_predictions:
        self._calc_inference_full(max_elms=max_elms)
    _, axes = plt.subplots(ncols=2, nrows=2, figsize=(12, 6))
    axes = axes.flat
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    signals = self.vel_predictions["signals"]
    vZ_labels = self.vel_predictions["vZ_labels"]
    vR_labels = self.vel_predictions["vR_labels"]
    vZ_predictions = self.vel_predictions["vZ_predictions"]
    vR_predictions = self.vel_predictions["vR_predictions"]

    # Pad labels and predictions to account for signal window
    l_diff = len(signals) - len(vZ_labels)
    vZ_labels = np.pad(vZ_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vR_labels = np.pad(vR_labels, ((l_diff, 0), (0, 0), (0, 0)))
    vZ_predictions = np.pad(vZ_predictions, ((l_diff, 0), (0, 0), (0, 0)))
    vR_predictions = np.pad(vR_predictions, ((l_diff, 0), (0, 0), (0, 0)))

    elm_time = np.arange(len(signals))
    # plot signal, labels, and prediction
    axes[0].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[0].plot(elm_time, vZ_labels.mean(axis=(1, 2)) / np.max(vZ_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[0].plot(elm_time,
                 vZ_predictions.mean(axis=(1, 2)) / np.max(vZ_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[0].set_xlabel("Time (micro-s)")
    axes[0].set_ylabel("Signal")
    axes[0].legend(fontsize='small')
    axes[0].set_title(f'vZ')

    axes[1].plot(elm_time, signals[:, 2, 6] / np.max(signals[:, 2, 6]), label="BES ch 22", alpha=0.5, zorder=0.0)
    axes[1].plot(elm_time, vR_labels.mean(axis=(1, 2)) / np.max(vR_labels.mean(axis=(1, 2))),
                 label="Ground truth",
                 alpha=0.5,
                 zorder=1.0)
    axes[1].plot(elm_time,
                 vR_predictions.mean(axis=(1, 2)) / np.max(vR_predictions.mean(axis=(1, 2))),
                 label="Mean Prediction",
                 alpha=0.5,
                 zorder=2.0)
    axes[1].set_xlabel("Time (micro-s)")
    axes[1].set_ylabel("Signal")
    axes[1].legend(fontsize='small')
    axes[1].set_title(f'vR')

    time_slice = time_slice if time_slice else len(signals)//2
    axes[2].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    Y, X = np.mgrid[0:8, 0:8]
    axes[2].quiver(X, Y, vR_labels[time_slice], vZ_labels[time_slice])
    axes[2].set_xlabel('R')
    axes[2].set_ylabel('Z')
    axes[2].set_title('ODP Calculated Velocity Field')

    axes[3].imshow(signals[time_slice], interpolation='hanning', cmap='gist_stern', alpha=0.8,
                   norm=TwoSlopeNorm(vcenter=1.2))
    axes[3].quiver(X, Y, vR_predictions[time_slice], vZ_predictions[time_slice])
    axes[3].set_xlabel('R')
    axes[3].set_ylabel('Z')
    axes[3].set_title('ML Calculated Velocity Field')

    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f'inference.pdf'
        print(f'Saving inference file: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
plot_full_inference(run, 0)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=0)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=5000)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=4000)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=3000)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=2000)
-. . -..- - / . -. - .-. -.--
plot_full_inference(run, time_slice=1000)
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification/analyze.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification')
-. . -..- - / . -. - .-. -.--
run.test_data['signals'].max()
-. . -..- - / . -. - .-. -.--
run.test_data['labels'].max()
-. . -..- - / . -. - .-. -.--
run._calc_inference_full()
-. . -..- - / . -. - .-. -.--
plot_full_inference(run)
-. . -..- - / . -. - .-. -.--
run.plot_full_inference()
-. . -..- - / . -. - .-. -.--
run.plot_full_analysis()
-. . -..- - / . -. - .-. -.--
f = 0
for key, d in run.elm_predictions.items():
    m = d['labels'].max()
    print(m)
    f+=1
print(f)    
-. . -..- - / . -. - .-. -.--
f = 0
for key, d in run.elm_predictions.items():
    m = d['predictions'].max()
    f+=1
print(f)    
-. . -..- - / . -. - .-. -.--
def plot_full_analysis(
        self,
        threshold: Union[float, None] = None,
        max_elms = None,
):
    if threshold is None:
        threshold = self.args.threshold
    if self.elm_predictions is None:
        self._calc_inference_full(threshold=threshold, max_elms=max_elms)
    _, axes = plt.subplots(nrows=2, ncols=2, figsize=(8, 6))
    plt.suptitle(f"{self.run_dir_short} | Test data (full)")
    for mode in ['micro', 'macro']:
        # gather micro/macro results
        targets = []
        predictions = []
        for vals in self.elm_predictions.values():
            prediction_key = 'predictions' if mode == 'micro' else 'macro_predictions'
            predictions.append(vals[prediction_key])
            label_key = 'labels' if mode == 'micro' else 'macro_labels'
            targets.append(vals[label_key])
        predictions = np.concatenate(predictions)
        targets = np.concatenate(targets)
        # plot ROC (micro only)
        if mode == 'micro':
            fpr, tpr, thresh = metrics.roc_curve(targets, predictions)
            plt.sca(axes.flat[0])
            plt.plot(fpr, tpr)
            plt.xlabel('False positive rate')
            plt.ylabel('True positive rate')
            plt.title('ROC')
            roc_auc = metrics.roc_auc_score(targets, predictions)
            plt.annotate(
                f'ROC-AUC = {roc_auc:.2f}',
                xy=(0.5, 0.03),
                xycoords='axes fraction',
            )
            plt.sca(axes.flat[1])
            plt.plot(thresh, tpr, label='True pos. rate')
            plt.plot(thresh, fpr, label='False pos. rate')
            plt.title('TPR/FPR')
            plt.xlabel('Threshold')
            plt.ylabel('Rate')
            plt.xlim(0,1)
            plt.legend()
        # confusion matrix heatmaps
        if mode == 'micro':
            bool_predictions = (predictions > threshold).astype(int)
            cm = metrics.confusion_matrix(targets, bool_predictions)
            print(cm)
        else:
            cm = metrics.confusion_matrix(targets, predictions)
        # plt.figure(figsize=(4.5, 3.5))
        # ax = plt.subplot(111)
        axis = axes.flat[2] if mode == 'micro' else axes.flat[3]
        plt.sca(axis)
        sns.heatmap(
            cm,
            annot=True,
            norm=LogNorm() if mode=='micro' else None,
            xticklabels=['No ELM', 'ELM'],
            yticklabels=['No ELM', 'ELM'],
        )
        plt.title(f'Conf. matrix ({mode}, thr={threshold:.2f})')
        plt.xlabel("Predicted label")
        plt.ylabel("True label")
    plt.tight_layout()
    if self.save:
        filepath = self.analysis_dir / f"full_analysis.pdf"
        print(f'Saving full-data analysis: {filepath.as_posix()}')
        plt.savefig(filepath.as_posix(), format='pdf', transparent=True)

-. . -..- - / . -. - .-. -.--
plot_full_analysis(run)
-. . -..- - / . -. - .-. -.--
plot_full_analysis(run, threshold=0.2)
-. . -..- - / . -. - .-. -.--
plot_full_analysis(run, threshold=0.3)
-. . -..- - / . -. - .-. -.--
plot_full_analysis(run, threshold=0.25)
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_classification')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_regression/train.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_regression')
-. . -..- - / . -. - .-. -.--
def plot_sample_elm(self, elm_index: int):
    if self.elm_predictions is None:
        self._calc_inference_full(elm_idx=elm_index)
    elm_data = self.elm_predictions[elm_index]

    fig, ax1 = plt.subplots(1, 1)
    ax2 = ax1.twinx()

    ax1.plot(elm_data['prediction'], color='tab:red', alpha=0.6)
    ax1.plot(elm_data['labels'], color='tab:red', label='Ground Truth')
    ax1.set_ylabel('Time to ELM')
    ax1.tick_params(axis='y', colors='tab:red')

    ax2.plot(elm_data['signals'][:, 2, 6], color='tab:blue', alpha=0.6, label='Ch. 22')
    ax2.set_ylabel('BES Activation')
    ax2.tick_params(axis='y', colors='tab:blue')

    ax1.set_xlabel('Time to ELM ($\mu$s)')
    ax1.legend()

-. . -..- - / . -. - .-. -.--
def _calc_inference_full(
        self,
        threshold=None,
        max_elms=None,
        elm_idx=None,
):
    if self.test_data is None:
        self._load_test_data()
    signals = self.test_data['signals']
    labels = self.test_data['labels']
    window_start = self.test_data['window_start']
    elm_indices = self.test_data['elm_indices']

    # Allow for selection of ELMs from elm_indices
    if elm_idx:
        elm_indices = elm_indices[[ix for (ix, idx) in enumerate(elm_idx) if (idx in elm_indices)]]

    if threshold is None:
        threshold = self.args.threshold

    n_elms = elm_indices.size
    sws_plus_la = (self.args.signal_window_size - 1) + self.args.label_look_ahead

    print('Running inference on full test data')
    elm_predictions = {}
    with torch.no_grad():
        for i_elm, elm_index in enumerate(elm_indices):
            if max_elms and i_elm >= max_elms:
                break
            i_start = window_start[i_elm]
            if i_elm < n_elms - 1:
                i_stop = window_start[i_elm + 1] - 1
            else:
                i_stop = labels.size
            elm_signals = signals[i_start:i_stop, ...]
            elm_labels = labels[i_start:i_stop]
            print(f"ELM {elm_indices[i_elm]:5d} ({i_elm+1:3d} of {n_elms})  "
                  f"Signal size: {elm_signals.shape}")
            predictions = []
            effective_len = elm_labels.size - sws_plus_la
            for j in range(effective_len):
                input_signals = elm_signals[j: j + self.args.signal_window_size, ...]
                input_signals = input_signals.reshape([1, 1, self.args.signal_window_size, 8, 8])
                input_signals = torch.as_tensor(input_signals, dtype=torch.float32)
                input_signals = input_signals.to(self.device)
                outputs = self.model(input_signals)
                predictions.append(outputs.item())
            predictions = np.array(predictions)
            # micro predictions
            predictions = np.pad(
                predictions,
                pad_width=(sws_plus_la, 0),
                mode="constant",
                constant_values=0,
            )
            macro_labels = None
            macro_predictions = None

            elm_predictions[elm_index] = {
                "signals": elm_signals,
                "labels": elm_labels,
                "predictions": predictions,
                "macro_labels": macro_labels,
                "macro_predictions": macro_predictions,
            }

    self.elm_predictions = elm_predictions

-. . -..- - / . -. - .-. -.--
plot_sample_elm(run, 4070)
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry/analyze.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/velocimetry')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_regression/analyze.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/elm_regression')
-. . -..- - / . -. - .-. -.--
runfile('/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification/analyze.py', wdir='/home/jazimmerman/PycharmProjects/bes-edgeml-models/bes-edgeml-models/bes_edgeml_models/turbulence_regime_classification')